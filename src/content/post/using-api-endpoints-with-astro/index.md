---
title: "Using API endpoints with Astro"
date: 2024-02-24
description: Astro stands out as a leading Static Site Generator (SSG), revered for its exceptional performance & top-notch SEO scores. But did you know how effortlessly it can evolve into a full-stack application boasting API routes and server-side rendering (SSR) pages?
abstract:  Astro stands out as a leading Static Site Generator (SSG), revered for its exceptional performance & top-notch SEO scores. But did you know how effortlessly it can evolve into a full-stack application boasting API routes and server-side rendering (SSR) pages?
draft: false
---

## Part 1 : Setup

Discover the boundless opportunities of API land 🌈 with Astro - Part 1

🏆 Astro stands out as a leading Static Site Generator (SSG), revered for its exceptional performance & top-notch SEO scores. But did you know how effortlessly it can evolve into a full-stack application boasting API routes and server-side rendering (SSR) pages?

📂 In Astro, routing revolves around the files housed within the "pages" folder. Let's explore this by integrating a few pages and API endpoints:

```
src/
└── pages
    ├── api
    │   ├── newsletter
    │   │   └── subscribe.ts
    │   └── subscribers
    │       ├── [id].ts
    │       └── index.ts
    └── index.astro
```

```
pages: Everything within the pages directory constitutes a route, as per Astro's behavior.
├── api: Contains our API routes; the choice of nomenclature is yours.
│   ├── newsletter
│   │   └── subscribe.ts: Listens for a POST request to subscribe.
│   └── subscribers
│       ├── [id].ts: GET - Fetches a specific subscriber using dynamic routing.
│       └── index.ts: GET - Retrieves all subscribers.
└── index.astro: The homepage.
```

🌐 While we could utilize static data, it's often more practical to incorporate dynamic data from a server. For example, a common use case involves fetching data from a database using a private key, a topic I'll delve into in the next post. Astro supports two rendering modes:

- Pre-rendered (SSG): The default mode, known as static, where the website is generated during build time.
- On-demand rendered (SSR): Routes can be customized for each viewer. Here, you have the option to choose between server or hybrid. Server involves generating all routes server-side during navigation, while hybrid denotes a static website with some pages being generated by the server.

🛠️ To opt for server mode, simply update the astro.config.mjs file:

```js
export default defineConfig({
  output: "server",
});
```

📚 Excited to explore this further? Check out the [Astro Rendering Modes](https://docs.astro.build/en/basics/rendering-modes/) documentation.

🚀 Stay tuned for the next posts where we'll dive deeper into dynamic data integration and advanced rendering techniques!

`#Astro #SSG #APIs #WebDevelopment` 💻🌟

Credits: rainbow image from https://unsplash.com/fr/@katierainbow
Image : [[20240218_AstroGuide-API-part1.png]]

---

## Part 2: GET

Discover the limitless possibilities of API integration 🌈 with Astro - Part 2

In continuation of our previous setup, we're eager to implement the following three API endpoints:

- GET `/api/subscribers/`
- GET `/api/subscribers/{id}` (where `{id}` is a dynamic route)
- POST `/api/newsletter/subscribe` with an email address

Let's start with the first GET request: `/api/subscribers/`

Firstly, we need to define the API route:

```ts
// File: ./src/pages/api/subscribers.ts
import type { APIRoute } from "astro";
const URL = "https://jsonplaceholder.typicode.com/users";

export const GET: APIRoute = async () => {
  const response = await fetch(URL);
  const data = await response.json();
  return new Response(JSON.stringify(data));
};

// Warning: Minimal fetching involved
// Note that you can utilize any JSON data source, whether static files or databases
```

You can now test the route by navigating to `http://localhost:4321/api/subscribers`. Remember, we've set up the `server` render mode.

The second step is to call our API endpoint and display the data on our landing page:

```jsx
---
// File: ./src/pages/index.astro

type SubscriberType = {
  id: number;
  name: string;
  email: string;
};

const response = await fetch(`${Astro.url.origin}/api/subscribers/`);
const subscribers: Array<SubscriberType> = await response.json();

---
<h1>Home page</h1>
<ul>
  { subscribers.map((subscriber) => (
	  <li><b>{subscriber.name}</b>: {subscriber.email}</li>
  ))}
</ul>
```

Instead of using `fetch`, you can also use the built-in Astro

```jsx
// From: https://docs.astro.build/en/recipes/call-endpoints/
import { GET } from '@/pages/api/subscribers/';
let response = await GET(Astro);
const subscribers: Array<SubscriberType> = await response.json();
```

📚 Eager to explore further? Check out the [APIContext](https://docs.astro.build/en/reference/api-reference/#endpoint-context) and [APIRoute](https://docs.astro.build/en/guides/endpoints/#http-methods) documentations.

🚀 Stay tuned for upcoming posts where we'll delve deeper into dynamic routes!

`#Astro #SSG #APIs #WebDevelopment` 💻🌟

Credits: rainbow image from https://unsplash.com/fr/@katierainbow

---

## Part 3: GET {id}

Remember where we left off with our project. We have succeeded in displaying all subscribers with this route:

```
src/
└── pages
    ├── api
    │   └── subscribers.ts : GET request for all subscribers
    └── index.astro : homepage
```

Now, we could improve it with two things:

- Move `subscribers.ts` to its own directory and rename it `index.ts`.
- Add a new route `/api/subscribers/{id}` to retrieve data for a single subscriber.

Note the naming convention in brackets for this dynamic route:

```
src
└── pages
    ├── api
    │   └── subscribers
    │       ├── [id].ts : new route
    │       └── index.ts : moved from api/subscribers.ts
    └── index.astro
```

The new route `/api/subscribers/{id}` can be tested by simply navigating to `http://localhost:4321/api/subscribers/1`, where you will receive data for the first user.

```ts
// File: ./src/pages/api/subscribers/[id].ts

import type { APIContext, APIRoute } from "astro";

const URL = "https://jsonplaceholder.typicode.com/users";

export const GET: APIRoute = async ({ params }: APIContext) => {
  const id = params.id; // Get the params from the request
  // params is an object containing the values of dynamic route segments matched for this request.
  const response = await fetch(`${URL}/${id}`);
  const data = await response.json();
  return new Response(JSON.stringify(data));
};
```

Then, simply add another fetch to get one subscriber to your `index.astro` file:

```jsx
---
// File: ./src/pages/index.astro

type SubscriberType = {
  id: number;
  name: string;
  email: string;
};

const response = await fetch(`${Astro.url.origin}/api/subscribers/2`);
const secondSubscriber: SubscriberType = await response.json();
---
<h1>Home page</h1>
<h2>Get the second subscriber</h2>
<p><b>{secondSubscriber.name}</b>: {secondSubscriber.email}</p>
```

Code: https://github.com/jeromeabel/astro-playground/tree/a11ed1b79456452380af9b3e11919c09bd86f072

---

## Part 4: POST avec redirection

📂 Let's add some routes to our last project:

- The API endpoint `api/subscribers/add.ts` will wait for a POST request and redirect to success or failure pages.
- Two pages, `newsletter/failure.astro` and `success.astro`.

```
src
└── pages
    ├── api
    │   └── subscribers
    │       ├── add.ts
    │       ├── [id].ts
    │       └── index.ts
    ├── index.astro
    └── newsletter
        ├── failure.astro
        └── success.astro
```

POST

The first method is to get data from the form, make some validations, and redirect to success and failure pages.

The redirect method is only available in server mode.

```ts
// File: src/pages/api/subscribers/add.ts

import type { APIRoute, APIContext } from "astro";

export const POST: APIRoute = async ({ request, redirect }: APIContext) => {
  const formData = await request.formData(); // Get data from the form
  const email = formData.get("email") as string;
  // Redirect if the email is not from Steve Rogers
  if (email === "steve@rogers.com") {
    return redirect("/newsletter/success", 307);
  }
  return redirect("/newsletter/failure", 307);
};
```

Just write these two dummy pages:

```html
<!-- File: src/pages/newsletter/success.astro -->
<h1>Success! Welcome Steve!</h1>
```

```html
<!-- File: src/pages/newsletter/failure.astro -->
<h1>Oups, failure!</h1>
```

Let's add a minimal form to the home page.

Note the action's path.

```html
<!-- File: src/pages/index.astro -->
<form method="POST" action="/api/subscribers/add">
  <label>
    Email address
    <input type="email" name="email" />
  </label>
  <button type="submit">Subscribe</button>
</form>
```

We could improve this a little bit by adding some error messages.

In the API, just change the URL with a message parameter:

```ts
// File: src/pages/api/subscribers/add.ts
return redirect(
  "/newsletter/failure?message=So bad, you are not Steve Rogers!",
  307,
);
```

In the failure page, get the messages thanks to "Astro.url.searchParams":

```jsx
---
// File: src/pages/newsletter/failure.astro
const message = Astro.url.searchParams.get("message")
---
<h1>Oups, failure!</h1>
<p> {message || "Something went wrong"} </p>
```

Code
https://github.com/jeromeabel/astro-playground/tree/065fa2e1235202e4b3f931bfe69d80bc5eed3de9

References

- https://developer.mozilla.org/en-US/docs/Web/API/FormData
- https://docs.astro.build/fr/reference/api-reference/#contextredirect

---

## Part 5: POST avec messages JSON

📂 Here, instead of using redirection when we have succeeded or failed to add "steve@rodgers.com" with our POST route, we will implement error messages directly on the same page.

```
src
└── pages
    ├── api
    │   └── subscribers
    │       └── add2.ts
    └── index.astro
```

Second method: send messages with JSON

```jsx
// http://localhost:4321/api/subscribers/add2
// File: src/pages/api/subscribers/add2.ts

import type { APIRoute, APIContext } from 'astro';

export const POST: APIRoute = async ({ request, redirect }: APIContext) => {
  const formData = await request.formData();
  const email = formData.get('email') as string;
  if (email === 'steve@rogers.com') {
    return new Response(
      JSON.stringify({ msg: 'Welcome Steve! Subscribed successfully!' }),
      { status: 200 }
    );
  }
  return new Response(
    JSON.stringify({
      msg: `Hey! ${email}, sorry, you're' not Steve Rogers...`,
    }),
    { status: 200 }
  );
};
```

Homepage

We handle form submission in JavaScript, so we don't need the action attribute. We receive messages in the paragraph below.

```jsx
<!-- File: src/pages/index.astro -->
<form method='POST' id='newsletterForm'>
	<label>
		Email address
		<input type='email' name='email' />
	</label>
	<button type='submit'>Subscribe</button>
</form>
<p id='newsletterFormMessage'>Tip: try steve@rogers.com to subscribe</p>

<script>
  document.addEventListener('DOMContentLoaded', function () {
    const form =
    document.getElementById('newsletterForm') as HTMLFormElement;
    const messageParagraph =
    document.getElementById('newsletterFormMessage') as HTMLParagraphElement;

    if (!form) {
      console.error('Form not found');
      return;
    }

    form.addEventListener('submit', async function (event) {
      event.preventDefault();
      const formData = new FormData(event.currentTarget as HTMLFormElement);

      try {
        const response = await fetch('/api/subscribers/add2', {
          method: 'POST',
          body: formData,
        });
        const data = await response.json();
        if (data) { messageParagraph.textContent = data.msg; }
      } catch (error) {
        console.error('Error:', error);
        messageParagraph.textContent = 'An error occurred';
      }
    });
  });
</script>
```

Code: https://github.com/jeromeabel/astro-playground/tree/509d599320d66c9bca18d3b6baa1d5137d95d04c
